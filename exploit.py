#!/usr/bin/env python3

from time import sleep
import socket
import sys
import telnetlib

def _p8(num):
    return num.to_bytes(1, byteorder='little')

def _p16(num):
    return num.to_bytes(2, byteorder='little')

def _p32(num):
    return num.to_bytes(4, byteorder='little')

def _p64(num):
    return num.to_bytes(8, byteorder='little')

def u8(byte_string):
    if 1 < len(byte_string):
        print('Error: u8 gets too long string({})'.format(byte_string))
        sys.exit(1)
    return int.from_bytes

def u16(byte_string):
    if 2 < len(byte_string):
        print('Error: u16 gets too long string({})'.format(byte_string))
        sys.exit(1)
    byte2 = byte_string.ljust(2, b'\0')
    return int.from_bytes(byte2, byteorder='little')

def u32(byte_string):
    if 4 < len(byte_string):
        print('Error: u32 gets too long string({})'.format(byte_string))
        sys.exit(1)
    byte4 = byte_string.ljust(4, b'\0')
    return int.from_bytes(byte4, byteorder='little')

def u64(byte_string):
    if 8 < len(byte_string):
        print('Error: u64 gets too long string({})'.format(byte_string))
        sys.exit(1)
    byte8 = byte_string.ljust(8, b'\0')
    return int.from_bytes(byte8, byteorder='little')

def p8(*nums):
    data = b''
    for num in nums:
        data += _p8(num)
    return data

def p16(*nums):
    data = b''
    for num in nums:
        data += _p16(num)
    return data

def p32(*nums):
    data = b''
    for num in nums:
        data += _p32(num)
    return data

def p64(*nums):
    data = b''
    for num in nums:
        data += _p64(num)
    return data

def xencode(string):
    if type(string) is str:
        return string.encode('ascii')
    else:
        return string

# This is the modified version of interact() in telnetlib.
# This version can receive non-ascii data.
# Original interact() is here:
#     https://github.com/python/cpython/blob/master/Lib/telnetlib.py
def _xinteract(tel):
    import selectors
    with telnetlib._TelnetSelector() as selector:
        selector.register(tel, selectors.EVENT_READ)
        selector.register(sys.stdin, selectors.EVENT_READ)

        while True:
            for key, events in selector.select():
                if key.fileobj is tel:
                    try:
                        text = tel.read_eager()
                    except EOFError:
                        print('*** Connection closed by remote host ***')
                        return
                    if text:
                        string = text.decode('ascii', 'backslashreplace')
                        sys.stdout.write(string)
                        sys.stdout.flush()
                elif key.fileobj is sys.stdin:
                    line = sys.stdin.readline().encode('ascii')
                    if not line:
                        return
                    tel.write(line)

class PwnSocket:
# timeout doesn't work in shell()
    def __init__(self, ip, port, _timeout=None):
        self.is_silent = False
        self.sock = socket.create_connection((ip, port), timeout=_timeout)

    def close(self):
        self.sock.close()

    def shell(self):
        tel = telnetlib.Telnet()
        tel.sock = self.sock
        _xinteract(tel)

    def print(self, byte_str):
        if not self.is_silent:
            string = byte_str.decode('ascii', 'backslashreplace')
            sys.stdout.write(string)
            sys.stdout.flush()

    def send(self, msg):
        msg = xencode(msg)
        self.print(msg)
        self.sock.send(msg)

    def sendline(self, msg):
        self.send(xencode(msg) + b'\n')

    def sendint(self, num):
        self.sendline(str(num))

    def recv(self, num):
        data = self.sock.recv(num)
        self.print(data)
        return data

    def recvuntil(self, delim):
        data = b''
        while not data.endswith(xencode(delim)):
            tmp = self.recv(1)
            data += tmp
        return data

    def recvline(self):
        return self.recvuntil(b'\n')

    def set_silent(self):
        self.is_silent = True

    def unset_silent(self):
        self.is_silent = False

def main(target):
    if target == 'remote':
        hostname = 'www.google.com'
        ip = socket.gethostbyname(hostname)
        port = 54321
    else:
        hostname = 'localhost'
        ip = socket.gethostbyname(hostname)

    if target == 'debug':
        port = 12345
    elif target == 'no-debug':
        port = 23456

    ps = PwnSocket(ip, port)

    ps.shell()

if __name__ == '__main__':
    if len(sys.argv) == 2 and sys.argv[1] == '--remote':
        target = 'remote'
    elif len(sys.argv) == 2 and sys.argv[1] == '--no-debug':
        target = 'no-debug'
    else:
        target = 'debug'
    main(target)
